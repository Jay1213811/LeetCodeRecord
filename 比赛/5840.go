package main
/*
给你一个字符串 s ，下标从 0 开始 ，且长度为偶数 n 。
字符串 恰好 由 n / 2 个开括号 '[' 和 n / 2 个闭括号 ']' 组成。
思路：
输入：s = "][]["
输出：1

对于一个平衡字符串，从左往右遍历它，统计未匹配的左括号的个数 c，遇到左括号就加一，
遇到右括号就减一，如果任何时刻 c 都不为负数，那么这个字符串就是平衡的。

如果遍历时遇到右括号并且此时 c=0，那么就需要在后面找一个左括号并与这个右括号交换。

为了使后续的交换次数最小，这个被交换走的右括号应当越靠右越好，
所以我们可以拿字符串最右边的左括号来交换。

实际代码中，可以不用编写「交换」的逻辑，这是因为我们总是选择最右边的左括号，
因此在后续的遍历中，若遇到了这些左括号，在交换后的字符串上，该位置及后面必然全部是右括号，
即此时该字符串已经是平衡的了。

因此，当遇到右括号并且此时 c=0可以直接将 c和答案加一，
即视作将一个左括号和该右括号交换。由于没有实际交换括号，若后面又重新遇到了需要被交换的左括号，由于此时字符串已经是平衡的了，故不会对答案产生影响。

*/
import (
	"fmt"

)
func minSwaps(s string) (ans int) {
	num:=0
	length:=len(s)
	for i:=0;i<length;i++{
		if s[i]=='['{
			num++
		}else if num>0{
			num--
		}
	}
	return (num+1)/2
}


func main()  {
	b:="]]][[["
	c:="[]"
	fmt.Println(minSwaps("][]["))
	fmt.Println(minSwaps(b))
	fmt.Println(minSwaps(c))
}